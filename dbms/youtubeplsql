set SERVEROUTPUT on;

DECLARE
message VARCHAR2(50);
begin
message:='Let DO it';
dbms_output.put_line(message);
end;

-----------------------------------

created a table for future use 

CREATE TABLE Employee (
    Emp_id INT PRIMARY KEY not null,
    Emp_name VARCHAR2(40) not null,
    Emo_salary INT not null, 
    Dept_id INT not null
    );

``` how to incese font in sql developer - tools- preference - code editor font ```

inserted values

insert into employee values(1,'name1',40000,1);
insert into employee values(2,'name2',35000,2);
insert into employee values(3,'name3',50000,2);
insert into employee values(4,'name4',40000,1);
insert into employee values(5,'name5',30000,3);
insert into employee values(6,'name6',50000,4);
insert into employee values(7,'name7',60000,4);
insert into employee values(8,'name8',40000,4);

set SERVEROUTPUT on; run for getting output

how to declare variable and display output in pl/sql

declare
name employee.Emp_name%type;
salary employee.Emo_salary%type;
msg number;
begin
select Emp_name,Emo_salary into name,salary from employee where Emp_id=&msg;
dbms_output.put_line(name);
dbms_output.put_line(salary);
end;

loop in pl/sql - must atleast be one exit when statement in loop

DECLARE
i number :=0;
begin
LOOP
i :=i+1;
exit when i>10;
dbms_output.put_line('value of i is :' || i);
END LOOP;
END;

other way

DECLARE
i number :=0;
begin
LOOP
i :=i+1;
IF i>10 THEN
exit;
IF END;
dbms_output.put_line('value of i is :' || i);
END LOOP;
END;

more way for loop

DECLARE
i number :=0;
j number :=0;
BEGIN
<<outer_loop>> LOOP
i:= i+1;
exit outer_loop when i>2;
dbms_output.put_line('outer loop :' || i);
j:=0;
<<inner_loop>> LOOP
j:=j+1;
exit inner_loop when j>3;
dbms_output.put_line('inner loop: ' || j);
END LOOP inner_loop;
END LOOP outer_loop;
END;


while loop ------
it will execute till the statement is true  

DECLARE
i number :=0;
begin
while i<=10
loop
dbms_output.put_line('value of i:' || i);
i:=i+1;
END LOOP;
END;

FOR loop __________

begin
FOR i IN 1..5 LOOP
dbms_output.put_line('value of i: ' || i);
END LOOP;
END;

--- IMP PRINT DETAIL OF EMPLOYEE WHOSE SALARY IS 40000

begin
FOR e IN (select * from employee) LOOP
if e.emo_salary=40000 then
dbms_output.put_line('Id: ' || e.emp_id || ',name:' || e.emp_name || ',salary:' || e.emo_salary);
END IF;
END LOOP;
END;

--for loop
declare
var1 number;
begin
var1:=100;
for var2 IN 1..10 loop
dbms_output.put_line(var1*var2);
End LOOP;
End;

-- from now notes wil be here before this it is in copy please refer

cursor
when an sql statement is processed, oracle create a memory area know as context area
a cursor is a pointer to this context area
it contains all information needed for processing the statement
in pl/sql the context areais controlled by cursor.
a cursor contains information on a select statement and the rowsof the data accessed by it
cursor use for processing row  by row

two type of cursor
implicit cursors
explicit cursors

cursor arttribute
%isopen - if cursor is open true other wise it return false 
%FOund - if records fetched by cursor was success then true otherwise false
%NOTFOUND  - opoosite of %found - return true if records fetched by unsuccess then true otherwise false
%Rowcount - it return the no of the rows affected by pl/sql statement


implicit cursors

- are automatically  generated by oracle while an sql  statement is executed
- these  are created by default to process the statement when dml statement like insert,update,delete etc are executed

-- note use only single quotes in printing the data
-- ouestion  we want to increase the salary and also display thre row effected

declare
total_rows number;
begin
update employee set emp_salary= emp_salary + 5000;
if sql%NOTFOUND then
dnms_output.put_line('record are not updated')
elsif sql%FOund then 
total_rows:=sql%Rowcount;
dbms_output.put_line('total rows updated'|| total_rows);
end if;
end;


explicit cursor
- declare by programer for more control over context area
- cursor should be defined in declaration section
- created on a select statement which return more than one row
syntax

steps
1. declare the cursor
2. open the cursor to allocate memory
3. fetch the cursor to retrieve data
4. close the cursor to release allocated memory

in example syntax is there 

-- 

declare
e_id employee.emp_id%type;
e_name employee.emp_name%type;
e_salary employee.emo_salary%type;
CURSOR e_employee is
select emp_id,emp_name,emo_salary from employee;
BEGIN
open e_employee;    
LOOP
fetch e_employee into e_id,e_name,e_name;
exit when e_employee%NOTFOUND;
dbms_output.put_line(e_id||': '||e_name||': '||e_salary);
end loop;
close e_employee;
end;


triggers
- are stored programs
- which automatically execute or fired (before/after) occurrence of some events

events are
1. database manipulation dml statement(delete,insert,update)
2. database defination ddl statement(create,alter,drop)
3. database operation (serverError,logon,logoff,startup , shutdown)

-- create table new_employee(id number primary key,salary number,message VARCHAR2(60));
-- so question is to make a triggers so that whenever in employee table salary is updated the info updated salary e_id will be stored in new_employee table 
-- below did not worked
create triggers trigger_emp
after update of emo_salary on employee
for each row
begin
insert into new_employee(id,salary,message)
values(:old.emp_id,:new.emp_salary,'Record is updated')
end;


procedure

- is a pl/sql block which perform one or more specific tasks
- procedure is mainly created to perform one or more dml operation over database
- it is not mandatory to return the value

syntax
create replace
is as
...
-- procedure it optional for taking parameter
-- first procedure 
create or replace procedure welcome
as
begin
dbms_output.put_line('welcone anuj kumar sharma')
end;

to run a procedure
begin
welcome;
end;

-- create table department(dept_id number primary key,dept_name varchar(30));
-- insert into department

-- insert into department values(1,'IT');
-- insert into department values(2,'HR');
-- insert into department values(3,'MEDICAL');
-- insert into department values(4,'INSURANCE');
-- insert into department values(5,'QUALITY');


create or replace procedure insert_dept(
    dept_id in number,dept_name in varchar2
)
is 
begin
insert into department values(dept_id,dept_name)
end;

begin
insert_dept(6,'RECEPTION');
end;


create or replace procedure update_emp(
    id in number,amount in number,d out number
)
is
begin
update employee set emo_salary= emo_salary+amount
where emp_id=id;
select emo_salary into d from employee where emp_id=id;
dbms_output.put_line('updated salary '|| d);
end;

-- did not run below code
-- variable k number;
-- execute update_emp(1,10000,:k);

functions

-pl/sql function is very similat to pl/sql procedure, but a function must always return a value
-use return to return the value
-retrun datatypeis mandatory at the time of creation
- used mainly to perform some calculation

syntax

create or replace function add_number(
    n1 in number,n2 in number
)
return number
is
n3 number;
begin
n3:=n1+n2;
return n3;
end add_numberk;

declare
n3 number;
begin
n3:=add_number(34,37);
dbms_output.put_line('add of number is '||n3);
end;

create or replace function update_sal(
    id in number,amount in number
)
return number
is
d number;
begin
update employee set emo_salary=emo_salary+amount where emp_id=id;
select emo_salary into d from employee where emp_id=id;
dbms_output.put_line('updated salary is'|| d);
return d;
end update_sal;

DECLARE
d number;
begin
d:=update_sal(2,2020);
end;

exception handling

-an error during the program execution is called execption in pl/sql
-two type:-
-pre-defined execption
-user-defined execption

pre-defined or system defined 
- they are many pre-defined execption which are executed when any database rule is violated by the program

in gallery picture of the execption


declare
e_id employee.emp_id%type;
e_name employee.emp_name%type;
begin
select emp_name into e_name from employee where emp_id=&e_id;
dbms_output.put_line(e_name);
exception when no_data_found THEN
dbms_output.put_line('no record found');
when others then
dbms_output.put_line('error!');
end;


raising exceptions
- all the predefined exception are raised implicitly whenever the error occurs.
- user-defined exception needs to be raised explicit
- this can be achieved using the keyword 'rasie'. this can be used in any of the ways mentioned below.

declare
n number:=&n;
ex_invaild exception;
begin
if n>5 then
raise ex_invaild;
else
dbms_output.put_line('n is less than 5');
end if;
exception when ex_invaild then
dbms_output.put_line('N is greater than 5');
end;


user-defined exception

declare
e_id employee.emp_id%type=&e_id;
e_name employee.emp_name%type;
ex_invalid exception;
begin
if e_id<=0 then
rasie ex_invalid;
else
select emp_name into e_name from employee where emp_id=&e_id;
dbms_output.put_line(e_name);
end if;
exception when ex_invalid then
dbms_output.put_line('emp_id should be greater than 0');
when no_data_found then
dbms_output.put_line('NO such employee');
when others then
dbms_output.put_line('Error!');
end;

package

-it is a schema object that contains defination for a group of related functionalities
-package includes variable,constant,cursor,execption,procedure and function
-package is compiled and stored as a database object that can be used later

components of package
-package specification
-package body

package specification
-it consist of all the public variable,cursor,object,procedure,function,and exception

syntax
create or replace package <package_name>
is
<sub_program and public element declaration>
end <package_name>;

_-imp
create or replace package package_department
as
procedure insert_department(dept_id in number,dept_name in varchar2);
procedure delete_department(delete_id in number);
function add_number(n1 in number,n2 in number)
return number;
end;

package body
-it consist of the defination of all the element that are present in the package specification

syntax
create or replace package body
<package name>
is
<global_declaration part>
<private element and public element defination>
.
<package initialization>
end <package_name>;

-imp

create or replace package body package_department
as
procedure insert_department(dept_id in number,dept_name in varchar2)
is
begin
insert into department values(dept_id,dept_name);
end insert_department;
procedure delete_department(delete_id in number)
is
begin
delete from department where dept_id=delete_id;
end delete_department;
function add_number(n1 in number,n2 in number)
return number
is
n3 number;
begin
n3:=n1+n2;
return n3;
end add_number;
end package_department;


begin
package_department.insert_department(7,'fun');
end;

begin
package_department.delete_department(7);
dbms_output.put_line('record deleted successfully')
end;

declare
n3 number;
begin
n3:= package_department.add_number(34,56);
dbms_output.put_line('sum :'||n3);
end;

-- now come the sql e-box question

CREATE OR REPLACE PROCEDURE display_reverse(
    n IN NUMBER
)
IS
BEGIN
    FOR i IN REVERSE 1..n LOOP
        DBMS_OUTPUT.PUT_LINE(i);
    END LOOP;
END;
/


SET SERVEROUTPUT ON;
DECLARE
    num_to_display NUMBER :=25 ; 
BEGIN
    display_reverse(num_to_display);
END;
/


--------------
CREATE OR REPLACE PROCEDURE computeArea(
    radius IN NUMBER,
    area OUT NUMBER,
    diameter OUT NUMBER,
    circumference OUT NUMBER
)
IS
    PI CONSTANT NUMBER := 3.142;
BEGIN
    area := PI * POWER(radius, 2);
    
    diameter := 2 * radius;
    
    circumference := 2 * PI * radius;
END;
/

SET SERVEROUTPUT ON;
DECLARE
    r NUMBER := 5;
    a NUMBER; 
    d NUMBER;
    c NUMBER; 
BEGIN
    computeArea(r, a, d, c);
    DBMS_OUTPUT.PUT_LINE(a);
    DBMS_OUTPUT.PUT_LINE(d);
    DBMS_OUTPUT.PUT_LINE(c);
END;
/
------
CREATE OR REPLACE PROCEDURE findAmount(
    personName IN VARCHAR2,
    entryTime IN TIMESTAMP,
    travelAmount OUT NUMBER
) AS
BEGIN
    SELECT amount INTO travelAmount
    FROM travel_payment
    WHERE entry_time = entryTime
    AND travel_card_id = (
      SELECT id
      FROM travel_card
      WHERE person_name = personName
    );

END;
/
--------
CREATE OR REPLACE PROCEDURE insertRoute(
    route_name IN VARCHAR2
) AS
    new_route_id NUMBER;
BEGIN
    SELECT COUNT(*) + 1 INTO new_route_id FROM route;

    INSERT INTO route (id, route_name) VALUES (new_route_id, route_name);
    
    COMMIT;
END;
/
------------imp
q--
Create a procedure named 'select_booking' that is used to display the details of the booking of a particular customer.
 This procedure takes cus_id as input and returns the booked_date,delivery_date,Car_Model_model_code of the booking under given cus_id. Display the details in ascending order by Car_Model_model_code. The booking details should be returned as 'sys_refcursor'.
The details must include the following:
booked_date,delivery_date,Car_Model_model_code.

Procedure name:    select_booking
Input parameter :    cus_id  
Output parameter:  booking_details with data type as SYS_REFCURSOR.
----------------ans--------------
CREATE OR REPLACE PROCEDURE select_booking(
    cus_id IN NUMBER,
    booking_details OUT SYS_REFCURSOR
) IS
BEGIN
    OPEN booking_details FOR
        SELECT booked_date, delivery_date, Car_Model_model_code
        FROM Booking b
        WHERE customer_id = cus_id
        ORDER BY Car_Model_model_code ASC;
END select_booking;
/

---------------
 Write a PL/SQL simple procedure named ‘display_manufacturer’ to display the manufacturer_code, manufacturer_name and total service_charge of all the models belonging to that manufacturer. Display the details of the manufacturer who have atleast one model of vehicle. Display the details in ascending order based on manufacturer_code.

Hint: Use cursor

Use the below skeleton:
Procedure name: display_manufacturer
------------
CREATE OR REPLACE PROCEDURE display_manufacturer IS
    CURSOR manufacturer_cursor IS
        SELECT m.manufacturer_code, m.manufacture_name, SUM(model.service_charge) AS total_service_charge
        FROM Manufacturer m
        JOIN Model ON m.manufacturer_code = Model.manufacturer_model_code
        GROUP BY m.manufacturer_code, m.manufacture_name
        HAVING COUNT(Model.model_code) > 0
        ORDER BY m.manufacturer_code ASC;

    v_manufacturer_code Manufacturer.manufacturer_code%TYPE;
    v_manufacturer_name Manufacturer.manufacture_name%TYPE;
    v_total_service_charge NUMBER;
BEGIN
    DBMS_OUTPUT.PUT_LINE('Manufacturer code  Manufacturer name Total Service Charge');
dbms_output.put_line('--------------------------------------------------------');
    OPEN manufacturer_cursor;
    LOOP
        FETCH manufacturer_cursor INTO v_manufacturer_code, v_manufacturer_name, v_total_service_charge;
        EXIT WHEN manufacturer_cursor%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE(v_manufacturer_code || ' ' || v_manufacturer_name || ' ' || v_total_service_charge);
    END LOOP;
    CLOSE manufacturer_cursor;
END display_manufacturer;
/
SET SERVEROUTPUT ON;

BEGIN
    display_manufacturer;
END;
/

-----------
create or replace function findTotalUnit(meterNumber in varchar2)
return varchar is
    avgUnits varchar(255);
begin
    select avg(total_units)
    into avgUnits
    from bill
    where meter_id in (
      select id
      from meter
      where meter_number = meterNumber)
    group by meter_id;

    return avgUnits;
end;
/
-------------
create or replace function showPayedOrNot(meterNumber in varchar2)
return varchar is
paid varchar(255);
begin
select case when is_payed = 0 then 'Payed' else 'Not Payed' end into paid
from bill
where meter_id = (
  select id
  from meter
  where meter_number = meterNumber);
  return paid;
end;
/
---------
create or replace function findRoute(metroTrainId int)
return varchar is
route varchar(255);
begin
select route_name into route
from route
where id in (
  select route_id
  from metro_train
  where id = metroTrainId);
return route;
end;
/
---------
create or replace function findTheScheduledTime(metroTrainId in int)
return varchar is
schedule varchar(255);
begin
select scheduled_time into schedule
from train_schedule
where metro_train_id = metroTrainId;
return schedule;
end;
/

=----------------
create or replace function find_dept_name(dept_id in int)
return varchar is
name varchar(255);
begin
select department_name into name
from department
where department_id = dept_id;
return name;
exception
when no_data_found then
name := 'No such department';
return name;
end;
/
---------------------------
create or replace function find_staff_name_by_dept(dept_id in int)
return varchar is
name varchar(255);
begin
  select staff_name into name
  from staff
  where department_id = dept_id;
return name;
exception
  when no_data_found then
    return 'No Such Department';
  when too_many_rows then
    return 'Multiple Rows Returned';
end;
/
----------------
create or replace procedure department_proc
(dept_id in number,dep_name in varchar, dep_bloc in number)
is
begin
insert into department
values(dept_id,dep_name,dep_bloc);
exception
  when dup_val_on_index then
    insert into department
    values(1000,dep_name,dep_bloc);
end;
/
--------
    CREATE OR REPLACE FUNCTION disp_block_name(dept_id IN NUMBER)
    RETURN VARCHAR2
    IS
        block_id NUMBER;
        block_name VARCHAR2(20);
    BEGIN
        SELECT department_block_number
        INTO block_id
        FROM department
        WHERE department_id = dept_id;

    CASE block_id
                    WHEN 1 THEN block_name := 'NORTH';
                    WHEN 2 THEN block_name := 'SOUTH';
                    WHEN 3 THEN block_name := 'EAST';
                    WHEN 4 THEN block_name := 'WEST';
                    ELSE RAISE CASE_NOT_FOUND;
                    END CASE;

        RETURN block_name;

    EXCEPTION
        WHEN CASE_NOT_FOUND THEN
            RETURN 'No Such Block';
    END;
    /
------ -----------------------------------------watch more carefully below -----
create or replace procedure department_procedure(dept_id in number)
is
    dept_name varchar(30);
    ex_invalid_id exception;
begin
    if dept_id < 0 then
        raise ex_invalid_id;
    else
        select department_name
        into dept_name
        from department
        where department_id = dept_id;
    end if;

exception
    when no_data_found then
        dbms_output.put_line('No Such Department');
    when ex_invalid_id then
        dbms_output.put_line('ID field must be greater than 0');
end;
/
----------
create or replace procedure insert_route(key_id in number, route_name in varchar2, status out varchar2)
is
begin
    insert into route
    values(key_id, route_name);
    status := 'Inserted successfully';
exception
    when dup_val_on_index then
        status := 'Sorry duplicate key is not allowed';
end;
/
-------
create or replace procedure select_metro_trains (routeId in varchar, status out varchar)
is
mt int;
begin
select id into mt from metro_train where route_id  = routeId;
status:=mt;
EXCEPTION 
when too_many_rows then 
status:= 'Sorry procedure wont return too many rows';
END;
/
-------------- 

create or replace trigger trigger_slab_insert
after insert on slab
for each row
begin
insert into slab_log_history
values(:new.id, :new.from_unit, :new.to_unit, :new.rate ,'Insert_Slab');
end;
/
------------
create or replace trigger trigger_electricity_conn_type
after insert on electricity_connection_type
for each row
begin
insert into electricity_conn_type_log
values(:new.id,:new.connection_name,'Insert_Electricity_Connection_Type');
end;
/
-----
create or replace trigger trigger_building_type_insert
after insert on building_type
for each row
begin
insert into building_type_log_history
values(:new.id,:new.connection_type_id,:new.name,'Insert_Building_Type');
end;
/
--------
create or replace trigger trigger_building_bf_update
before update on building
for each row
begin
insert into building_log_history
values(:old.id,:old.contact_number,'Before_Update_Building');
end;
/
------------
create or replace trigger trigger_meter_af_update
after update on meter
for each row
begin
insert into meter_log_history
values(:new.id,:new.meter_number,'After_Update_Meter');
end;
/
-------
create or replace trigger trigger_building_type_bf
before update on building_type
for each row
begin
insert into building_update_log_history
values(:old.id,:old.name,'Before_Update_Building_Type');
end;
/
-----
create or replace trigger trigger_electricity_af_update
after update on electricity_reading
for each row
begin
insert into electricity_reading_log
values(:new.id, :new.meter_id, :new.total_units, 'Af_Update_Electricity_Reading');
end;
/
------
create or replace trigger trigger_bill_delete
after delete on bill
for each row
begin
insert into bill_log_history
values(:old.id,:old.meter_id,:old.payable_amount,'After_Delete_Bill');
end;
/
--------
create or replace trigger trigger_slab_delete
after delete on slab
for each row
begin
insert into slab_log_history
values(:old.id,:old.from_unit,:old.to_unit,:old.rate,'After_Delete_Slab');
end;
/
-------
create or replace trigger tr_electricity_reading_delete
after delete on electricity_reading
for each row
begin
insert into electricity_reading_log
values(:old.id,:old.meter_id,:old.total_units,'Af_Delete_Electricity_Reading');
end;
/
-------
create or replace trigger trigger_travel_card_af_update
after update on travel_card
for each row
begin
insert into travel_card_log_history
values(:new.id,:new.person_name,'After_Update_Travel_Card');
end;
/


pacakge see more

CREATE OR REPLACE PACKAGE dept_package AS
    PROCEDURE addDepartment(
        dept_id IN department.department_id%TYPE,
        dept_name IN department.department_name%TYPE,
        dept_block_number IN department.department_block_number%TYPE
    );
    
    PROCEDURE deleteDepartment(
        dept_id IN department.department_id%TYPE
    );
    
    PROCEDURE listDepartment(
        dept_details OUT SYS_REFCURSOR
    );
    
    PROCEDURE updateDepartment(
        dept_name IN department.department_name%TYPE,
        new_dept_name IN department.department_name%TYPE
    );
END dept_package;
/

CREATE OR REPLACE PACKAGE BODY dept_package AS
    PROCEDURE addDepartment(
        dept_id IN department.department_id%TYPE,
        dept_name IN department.department_name%TYPE,
        dept_block_number IN department.department_block_number%TYPE
    ) IS
    BEGIN
        INSERT INTO department (department_id, department_name, department_block_number)
        VALUES (dept_id, dept_name, dept_block_number);
    END addDepartment;
    
    PROCEDURE deleteDepartment(
        dept_id IN department.department_id%TYPE
    ) IS
    BEGIN
        DELETE FROM department WHERE department_id = dept_id;
    END deleteDepartment;
    
    PROCEDURE listDepartment(
        dept_details OUT SYS_REFCURSOR
    ) IS
    BEGIN
        OPEN dept_details FOR
        SELECT department_id, department_name, department_block_number
        FROM department
        ORDER BY department_id;
    END listDepartment;
    
    PROCEDURE updateDepartment(
        dept_name IN department.department_name%TYPE,
        new_dept_name IN department.department_name%TYPE
    ) IS
    BEGIN
        UPDATE department
        SET department_name = new_dept_name
        WHERE department_name = dept_name;
    END updateDepartment;
END dept_package;
/

---------------
CREATE OR REPLACE PACKAGE subject_package AS
    PROCEDURE addSubject(
        sub_id IN subject.subject_id%TYPE,
        sub_name IN subject.subject_name%TYPE,
        sub_code IN subject.subject_code%TYPE,
        staff_id IN subject.staff_id%TYPE
    );
    
    PROCEDURE deleteSubject(
        sub_id IN subject.subject_id%TYPE
    );
    
    PROCEDURE listSubject(
        subject_details OUT SYS_REFCURSOR
    );
    
    PROCEDURE updateSubject(
        sub_name IN subject.subject_name%TYPE,
        new_sub_name IN subject.subject_name%TYPE
    );
END subject_package;
/

CREATE OR REPLACE PACKAGE BODY subject_package AS
    PROCEDURE addSubject(
        sub_id IN subject.subject_id%TYPE,
        sub_name IN subject.subject_name%TYPE,
        sub_code IN subject.subject_code%TYPE,
        staff_id IN subject.staff_id%TYPE
    ) IS
    BEGIN
        INSERT INTO subject
        VALUES (sub_id, sub_name, sub_code, staff_id);
    END addSubject;
    
    PROCEDURE deleteSubject(
        sub_id IN subject.subject_id%TYPE
    ) IS
    BEGIN
        DELETE FROM subject WHERE subject_id = sub_id;
    END deleteSubject;
    
    PROCEDURE listSubject(
        subject_details OUT SYS_REFCURSOR
    ) IS
    BEGIN
        OPEN subject_details FOR
        SELECT *
        FROM subject
        ORDER BY subject_id ASC;
    END listSubject;
    
    PROCEDURE updateSubject(
        sub_name IN subject.subject_name%TYPE,
        new_sub_name IN subject.subject_name%TYPE
    ) IS
    BEGIN
        UPDATE subject
        SET subject_name = new_sub_name
        WHERE subject_name = sub_name;
    END updateSubject;
END subject_package;
/
------------------
CREATE OR REPLACE PACKAGE staff_package AS
    PROCEDURE addStaff(
        id IN staff.staff_id%TYPE,
        name IN staff.staff_name%TYPE,
        dept_id IN staff.department_id%TYPE
    );
    
    PROCEDURE deleteStaff(
        id IN staff.staff_id%TYPE
    );
    
    PROCEDURE listStaff(
        staff_details OUT SYS_REFCURSOR
    );
    
    PROCEDURE updateStaff(
        name IN staff.staff_name%TYPE,
        new_name IN staff.staff_name%TYPE
    );
END staff_package;
/

CREATE OR REPLACE PACKAGE BODY staff_package AS
    PROCEDURE addStaff(
        id IN staff.staff_id%TYPE,
        name IN staff.staff_name%TYPE,
        dept_id IN staff.department_id%TYPE
    ) IS
    BEGIN
        INSERT INTO staff
        VALUES (id, name, dept_id);
    END addStaff;
    
    PROCEDURE deleteStaff(
        id IN staff.staff_id%TYPE
    ) IS
    BEGIN
        DELETE FROM staff WHERE staff_id = id;
    END deleteStaff;
    
    PROCEDURE listStaff(
        staff_details OUT SYS_REFCURSOR
    ) IS
    BEGIN
        OPEN staff_details FOR
        SELECT *
        FROM staff
        ORDER BY staff_id ASC;
    END listStaff;
    
    PROCEDURE updateStaff(
        name IN staff.staff_name%TYPE,
        new_name IN staff.staff_name%TYPE
    ) IS
    BEGIN
        UPDATE staff
        SET staff_name = new_name
        WHERE staff_name = name;
    END updateStaff;
END staff_package;
/
------------------
CREATE OR REPLACE PACKAGE calculator AS
    FUNCTION addNumbers(n1 NUMBER, n2 NUMBER) RETURN NUMBER;
    
    FUNCTION subtractNumbers(n1 NUMBER, n2 NUMBER) RETURN NUMBER;
    
    FUNCTION multiplyNumbers(n1 NUMBER, n2 NUMBER) RETURN NUMBER;
    
    FUNCTION divideNumbers(n1 NUMBER, n2 NUMBER) RETURN NUMBER;
END calculator;
/

CREATE OR REPLACE PACKAGE BODY calculator AS
    FUNCTION addNumbers(n1 NUMBER, n2 NUMBER) RETURN NUMBER IS
    BEGIN
        RETURN n1 + n2;
    END addNumbers;
    
    FUNCTION subtractNumbers(n1 NUMBER, n2 NUMBER) RETURN NUMBER IS
    BEGIN
        RETURN n1 - n2;
    END subtractNumbers;
    
    FUNCTION multiplyNumbers(n1 NUMBER, n2 NUMBER) RETURN NUMBER IS
    BEGIN
        RETURN n1 * n2;
    END multiplyNumbers;
    
    FUNCTION divideNumbers(n1 NUMBER, n2 NUMBER) RETURN NUMBER IS
    BEGIN
        IF n2 = 0 THEN
            RETURN NULL;
        ELSE
            RETURN n1 / n2;
        END IF;
    END divideNumbers;
END calculator;
/
----------------
